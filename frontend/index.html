<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>XYZCare Audio Assistant</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">


  <style>
    :root {
      --bg: #f8f9fa; --panel: #ffffff; --muted: #6c757d; --text: #212529; --accent: #007bff; --danger: #dc3545; --ok: #28a745;
    }
    * { box-sizing: border-box; }
    body {
      margin:0; padding:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg); color: var(--text);
    }
    header {
      padding: 16px 20px; border-bottom: 1px solid #dee2e6; background: #ffffffcc; position: sticky; top:0; backdrop-filter: blur(8px); z-index:10;
      display:flex; align-items:center; gap:14px;
    }
    .dot { width:10px; height:10px; border-radius:50%; background: var(--ok); box-shadow: 0 0 10px var(--ok); }
    h1 { margin:0; font-size: 18px; font-weight: 600; letter-spacing: .2px; }
    #sidebar-toggle { background: none; border: none; font-size: 24px; cursor: pointer; color: var(--text); }
    #sidebar { position: fixed; top: 64px; left: 0; height: calc(100% - 64px); width: 380px; background-color: var(--panel); border-right: 1px solid #dee2e6; padding: 16px; z-index: 100; transform: translateX(0); transition: transform 0.3s ease-in-out; box-shadow: 0 0 30px rgba(0,0,0,.1); } 
    #sidebar.closed { transform: translateX(-100%); }
    #main-content { margin-left: 380px; transition: margin-left 0.3s ease-in-out; padding: 16px; min-height: calc(100vh - 64px); } 
    #main-content.sidebar-closed { margin-left: 0; }
    @media (max-width: 980px) { 
      #sidebar { box-shadow: none; }
      #main-content { margin-left: 0; } 
      #sidebar.closed { display: none; }
    }
    .panel {
      background: var(--panel);
      border: 1px solid #dee2e6; border-radius: 12px; padding: 14px; box-shadow: 0 10px 30px rgba(0,0,0,.05);
    }
    .section-title { font-size: 13px; text-transform: uppercase; letter-spacing:.12em; color: var(--muted); margin: 0 0 8px 2px; }
    .mic-wrap { display:flex; flex-direction: column; align-items:center; gap:16px; margin: 20px 0; }
    #micBtn {
      appearance:none; 
      border: 2px solid rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      color: #007bff; 
      border-radius: 50%; 
      padding: 0;
      font-weight: 600; 
      cursor: pointer;
      box-shadow: 0 8px 32px rgba(0, 123, 255, 0.15), 
                  inset 0 1px 1px rgba(255, 255, 255, 0.5),
                  inset 0 -1px 1px rgba(0, 0, 0, 0.05);
      transition: all .3s cubic-bezier(0.4, 0, 0.2, 1);
      width: 80px;
      height: 80px;
      font-size: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }
    #micBtn::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0) 100%);
      opacity: 0;
      transition: opacity .3s ease;
    }
    #micBtn:hover::before { opacity: 1; }
    #micBtn:hover { 
      transform: translateY(-2px) scale(1.05); 
      box-shadow: 0 12px 40px rgba(0, 123, 255, 0.25),
                  inset 0 1px 1px rgba(255, 255, 255, 0.6),
                  inset 0 -1px 1px rgba(0, 0, 0, 0.05);
    }
    #micBtn:active {
      transform: translateY(0) scale(0.98);
    }
    #micBtn.recording {
      border-color: rgba(255, 255, 255, 0.4);
      background: rgba(220, 53, 69, 0.3);
      color: var(--danger);
      box-shadow: 0 8px 32px rgba(220, 53, 69, 0.3),
                  inset 0 1px 1px rgba(255, 255, 255, 0.5),
                  inset 0 -1px 1px rgba(0, 0, 0, 0.05);
      animation: pulse-recording 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }
    @keyframes pulse-recording {
      0%, 100% { 
        box-shadow: 0 8px 32px rgba(220, 53, 69, 0.3),
                    inset 0 1px 1px rgba(255, 255, 255, 0.5),
                    inset 0 -1px 1px rgba(0, 0, 0, 0.05);
      }
      50% { 
        box-shadow: 0 8px 40px rgba(220, 53, 69, 0.5),
                    inset 0 1px 1px rgba(255, 255, 255, 0.5),
                    inset 0 -1px 1px rgba(0, 0, 0, 0.05);
      }
    }
    #micHint { color: var(--muted); font-size: 12px; text-align: center; max-width: 280px; line-height: 1.4; }
    .keyboard-hint { 
      display: inline-flex; 
      align-items: center; 
      gap: 4px; 
      padding: 2px 6px; 
      background: rgba(0, 0, 0, 0.05); 
      border-radius: 4px; 
      font-family: ui-monospace, monospace; 
      font-size: 11px;
      font-weight: 600;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }
    .kv { display:grid; grid-template-columns: 110px 1fr; font-size: 13px; gap: 6px 10px; color: var(--muted); }
    .kv div.value { color: var(--text); font-weight: 600; }
    .status {
      display:flex; align-items:center; gap:10px; flex-wrap: wrap; margin-top: 10px;
    }
    .pill { font-size: 12px; padding: 6px 10px; border-radius: 999px; border:1px solid #ced4da; color: var(--muted); }
    .pill.ok { color: var(--ok); border-color: var(--ok); }
    .pill.warn { color: #ffc107; border-color: #ffc107; }
    .pill.err { color: var(--danger); border-color: var(--danger); }
    #log {
      height: 180px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px;
      background: #e9ecef; border-radius: 8px; border:1px solid #ced4da; padding: 8px; color:#495057;
      white-space: pre-wrap;
      word-break: break-all;
    }
    #cardsContainer {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 16px;
      margin-top: 16px;
    }
    .card {
      background: var(--panel);
      border: 1px solid #dee2e6;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,.05);
      transition: all 0.2s ease;
    }
    .card:hover {
      box-shadow: 0 4px 16px rgba(0,0,0,.1);
      transform: translateY(-2px);
    }
    .card-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 8px;
    }
    .card-page {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .card-snippet {
      font-size: 14px;
      line-height: 1.5;
      color: var(--text);
    }
    .toast { margin-top: 10px; font-size: 13px; color: var(--text); }
    a { color: var(--accent); }
  </style>
</head>
<body>
  <header>
    <button id="sidebar-toggle" aria-label="Toggle sidebar">â˜°</button>
    <span class="dot" aria-hidden="true"></span>
    <h1>XYZCare Audio Assistant</h1>
  </header>

  <div id="sidebar">
    <section class="panel" aria-label="Voice Controls">
      <p class="section-title">Controls</p>
      <div class="mic-wrap">
        <button id="micBtn" aria-pressed="false" aria-label="Hold to speak or click to start/stop recording">
          ðŸŽ¤
        </button>
        <span id="micHint">Say product name first (e.g., "LG Refrigerator Manual"), then ask questions (e.g., "Load Driver Circuit"). Press <span class="keyboard-hint">SPACE</span> to activate voice.</span>
      </div>

      <div class="status">
        <div class="kv" style="margin-top:10px; flex: 1 1 100%;">
          <div>Manual</div><div class="value" id="manualVal">â€”</div>
          <div>Transcript</div><div class="value" id="transcriptVal">â€”</div>
        </div>
      </div>

      <div style="margin-top:12px;">
        <div class="section-title">Log</div>
        <pre id="log" aria-live="polite"></pre>
        <div class="toast" id="toast"></div>
      </div>
    </section>

    <!-- Instructions Panel -->
    <section class="panel" aria-label="Instructions" style="margin-top: 16px;">
      <p class="section-title">How to Use</p>
      <ol style="font-size: 13px; line-height: 1.7; color: var(--text); padding-left: 20px; margin: 0;">
        <li style="margin-bottom: 10px;">
          <strong>Load a manual:</strong> Say the product name<br>
          <span style="color: var(--muted); font-size: 12px;">Examples: "Pixel Fold Manual", "LG LFCC Manual", "LG Air Conditioner Manual"</span>
        </li>
        <li style="margin-bottom: 0;">
          <strong>Search within:</strong> Ask your technical question<br>
          <span style="color: var(--muted); font-size: 12px;">Example: "defrosting circuit"</span>
        </li>
      </ol>
    </section>
  </div>

  <div id="main-content">
    <section class="panel" aria-label="Manual Viewer">
      <p class="section-title">Manual</p>

      <!-- Cards container for search results -->
      <div id="cardsContainer">
        <!-- Cards will be dynamically added here -->
      </div>
    </section>
  </div>

  <script>
    (function () {
      const micBtn = document.getElementById('micBtn');
      const manualVal = document.getElementById('manualVal');
      const transcriptVal = document.getElementById('transcriptVal');
      const logEl = document.getElementById('log');
      const toastEl = document.getElementById('toast');
      const cardsContainer = document.getElementById('cardsContainer');
      const sidebar = document.getElementById('sidebar');
      const mainContent = document.getElementById('main-content');
      const sidebarToggle = document.getElementById('sidebar-toggle');

      sidebarToggle.addEventListener('click', () => {
        sidebar.classList.toggle('closed');
        mainContent.classList.toggle('sidebar-closed');
      });

      let mediaRecorder = null;
      let chunks = [];
      let isRecording = false;
      let state = {
        manualId: null,
        manualTitle: null,
        lastLatencyMs: null,
      };

      function log(msg) {
        const ts = new Date().toISOString().split('T')[1].replace('Z','');
        logEl.textContent += '[' + ts + '] ' + msg + '\n';
        logEl.scrollTop = logEl.scrollHeight;
      }

      function toast(msg, persist = false) {
        toastEl.textContent = msg;
        if (!persist) {
          setTimeout(() => { toastEl.textContent = ''; }, 4000);
        }
      }
      
      function clearToast() {
        toastEl.textContent = '';
      }

      // Function to add a card to the display
      function addCard(title, page, snippet) {
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `
          <div class="card-title">${title}</div>
          <div class="card-page">Page ${page}</div>
          <div class="card-snippet">${snippet}</div>
        `;
        cardsContainer.appendChild(card);
      }

      // Function to clear all cards
      function clearCards() {
        cardsContainer.innerHTML = '';
      }

      function chooseMime() {
        const preferred = ['audio/webm;codecs=opus', 'audio/webm'];
        for (const m of preferred) {
          if (MediaRecorder.isTypeSupported(m)) return m;
        }
        return ''; // Let browser decide
      }

      async function startRecording() {
        if (isRecording) return;
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          toast('Microphone not available.');
          log('MediaDevices.getUserMedia not supported');
          return;
        }
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const mimeType = chooseMime();
          chunks = [];
          mediaRecorder = new MediaRecorder(stream, mimeType ? { mimeType } : {});
          mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size > 0) chunks.push(e.data); };
          mediaRecorder.onstop = onStopRecording;
          mediaRecorder.start();
          isRecording = true;
          micBtn.classList.add('recording');
          micBtn.setAttribute('aria-pressed', 'true');
          log('Recording started...');
          // Auto-stop after 7 seconds for snappy demo
          setTimeout(() => { if (isRecording) stopRecording(); }, 7000);
        } catch (err) {
          console.error(err);
          toast('Failed to access microphone.');
          log('Error starting recording: ' + (err && err.message ? err.message : String(err)));
        }
      }

      function stopRecording() {
        if (!isRecording) return;
        isRecording = false;
        micBtn.classList.remove('recording');
        micBtn.setAttribute('aria-pressed', 'false');
        try {
          mediaRecorder.stop();
          log('Recording stopped. Processing...');
        } catch (e) {
          log('Error stopping recorder: ' + e);
        }
      }

      async function onStopRecording() {
        try {
          const blob = new Blob(chunks, { type: chunks[0]?.type || 'audio/webm' });
          await handleUtterance(blob);
        } catch (e) {
          log('onStop error: ' + e);
        } finally {
          // Cleanup tracks
          try {
            mediaRecorder.stream.getTracks().forEach(t => t.stop());
          } catch {}
        }
      }

      async function handleUtterance(audioBlob) {
        clearToast(); // Clear any persistent toast when starting new utterance
        const t0 = performance.now();
        transcriptVal.textContent = 'â€¦';
        const form = new FormData();
        const ext = (audioBlob.type.includes('wav') ? 'wav' : 'webm');
        form.append('file', audioBlob, 'audio.' + ext);

        let transcript = null;
        try {
          const resp = await fetch('/api/stt', { method: 'POST', body: form });
          const t1 = performance.now();
          if (!resp.ok) {
            let errorDetail = resp.statusText;
            try {
              const errorData = await resp.json();
              errorDetail = errorData.detail || resp.statusText;
            } catch (e) {
              // If can't parse JSON, use statusText
            }
            const msg = 'STT error: ' + resp.status + ' - ' + errorDetail;
            toast(msg);
            log(msg);
            transcriptVal.textContent = 'â€”';
            return;
          }
          const data = await resp.json();
          transcript = (data && data.transcript) ? data.transcript.trim() : '';
          transcriptVal.textContent = transcript || 'â€”';

          // Log transcript and timing
          const latency = t1 - t0;
          log('Transcript: ' + transcript);
          log('Latency: ' + Math.round(latency) + 'ms (Total), ' + (data.api_duration_ms || 'n/a') + 'ms (API)');

          if (!transcript) {
            toast('No speech detected.');
            return;
          }

          // Process transcript for manual resolution and search
          if (!state.manualId) {
            await resolveManual(transcript);
          } else {
            // Check if user wants to open/switch manuals
            // Only trigger on explicit "manual" keyword or action verbs "open"/"show"
            const lowerTranscript = transcript.toLowerCase();
            const isManualTrigger = lowerTranscript.includes('manual') ||
                                   lowerTranscript.startsWith('open ') ||
                                   lowerTranscript.startsWith('show ');

            if (isManualTrigger) {
              // User wants to switch manuals
              await resolveManual(transcript);
            } else {
              // Search within current manual
              await askWithinManual(transcript);
            }
          }

        } catch (e) {
          const t1 = performance.now();
          toast('Network error during STT.');
          log('STT exception: ' + e);
        }
      }

      async function resolveManual(query) {
        const url = '/api/manual/resolve?q=' + encodeURIComponent(query);
        log('Resolving manual: ' + query);
        const t0 = performance.now();
        try {
          const resp = await fetch(url);
          const t1 = performance.now();
          if (!resp.ok) {
            toast('Manual resolution failed (' + resp.status + ').');
            log('Resolve error: ' + resp.status + ' ' + resp.statusText);
            return;
          }
          const data = await resp.json();
          // Expected: { manual_id, title, filename }
          if (!data.manual_id) {
            toast('Ambiguous. Please be more specific.');
            log('Resolve response ambiguous: ' + JSON.stringify(data));
            return;
          }
          // Only switch manual if it's different from current one
          if (state.manualId !== data.manual_id) {
            state.manualId = data.manual_id;
            state.manualTitle = data.title || data.filename || ('Manual ' + data.manual_id);
            manualVal.textContent = state.manualTitle;

            // Clear existing cards and show manual loaded message
            clearCards();
            toast('Manual loaded: ' + state.manualTitle);
            log('Manual resolved: ' + state.manualTitle);
          } else {
            log('Manual already loaded: ' + state.manualTitle + '. Treating as search.');
            await askWithinManual(query);
          }
        } catch (e) {
          toast('Error resolving manual.');
          log('Resolve exception: ' + e);
        }
      }

      async function askWithinManual(question) {
        if (!state.manualId) return;
        const url = '/api/manual/' + encodeURIComponent(state.manualId) + '/search';
        log('Searching within manual: ' + question);
        const t0 = performance.now();
        try {
          const resp = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ question })
          });
          const t1 = performance.now();
          if (!resp.ok) {
            toast('Search failed (' + resp.status + ').');
            log('Search error: ' + resp.status + ' ' + resp.statusText);
            return;
          }
          const data = await resp.json();
          // Expected: { page, score, snippet }
          if (!data.page) {
            toast('No relevant section found.');
            log('Search response: ' + JSON.stringify(data));
            return;
          }
          // Add card with search result
          addCard(state.manualTitle, data.page, data.snippet || 'No snippet available');
          const summary = data.snippet ? (' â€” ' + data.snippet.slice(0, 140) + (data.snippet.length > 140 ? 'â€¦' : '')) : '';
          toast('ðŸ“„ Page ' + data.page + summary, true); // Persistent toast
          log('Rerank score: ' + (data.score !== undefined && data.score !== null ? data.score.toFixed(3) : 'n/a'));
        } catch (e) {
          toast('Error searching manual.');
          log('Search exception: ' + e);
        }
      }


      // Wire UI
      micBtn.addEventListener('click', () => {
        if (isRecording) stopRecording(); else startRecording();
      });

      // Keyboard shortcut: Spacebar to toggle recording
      document.addEventListener('keydown', (e) => {
        // Only trigger if not focused on an input element
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        if (e.code === 'Space' || e.key === ' ') {
          e.preventDefault(); // Prevent page scroll
          if (isRecording) {
            stopRecording();
          } else {
            startRecording();
          }
        }
      });

      log('UI loaded. Click the mic or press SPACE to speak.');
    })();
  </script>
</body>
</html>
